# Report for Assignment 1

# Problem 1:
## Problem Formulation

### Initital State:
Given input sequence of fairies.
### State Space: 
The state space represents all possible configurations of the fairies' symbols. Each state is represented as a list of integers, where each integer corresponds to the symbol of a fairy, and its position in the list represents the fairy's position in the row.

### Successor Function: 
The successor function takes a state and returns a list of successor states. In this case, the successor function generates states by swapping adjacent fairies, thus producing a new state for each valid swap.

### Edge Weights: 
The edge weights in this problem are not explicitly used in the A* search algorithm since the cost of transitioning from one state to another is uniform. The cost from the initial state to a state 's' is represented as 'g(s)' in the A* algorithm.

### Goal State: 
The goal state is a state in which the fairies are arranged in ascending order from 1 to N. In other words, the state matches the list [1, 2, 3, ..., N].For this question N is given as 5.

## Description of the Search Algorithm:
The search algorithm used in the code is A* search with a priority queue. Here's how it works:

1. Initialize an empty set 'visited' to keep track of visited states.
2. Create a priority queue 'pq' to store states with their priorities.
3. Push the initial state into 'pq' with a priority value of 'g(initial_state) + h(initial_state)', where 'g' is the cost from the initial state to itself (0), and 'h' is the heuristic value.
4. Create a dictionary 'path' to store the path from the initial state to each state encountered during the search.
5. While 'pq' is not empty, do the following:
   - Pop the state with the highest priority from 'pq'.
   - If the popped state is the goal state, return the path to the goal state.
   - Otherwise, expand the state by generating its successor states using the successor function.
   - For each successor state:
      - Calculate the cost to reach it ('new_cost') by incrementing the cost of the parent state.
      - Calculate the priority value for the successor using 'new_cost + h(successor)'.
      - If the successor is not visited, push it into 'pq' with its priority value and update the path.
      - If the search exhausts all possibilities without finding the goal state, return an empty path.

## Discussion:
### Heuristic Choice:
The heuristic function total_displacement was chosen because it satisfies the admissibility property and provides a reasonable estimate of the number of steps required to reach the goal state. However, other heuristics such as number of fairies out of place and number of inversions could have been explored.

### Assumptions: 
The code assumes that the input states are valid and can lead to a solvable puzzle. It does not check for unsolvable states. If no paths are found, it returns an empty list.

### Simplifications: 
The code does not use edge weights because the cost of transitioning between states is uniform (each swap has a cost of 1).

### Efficiency: 
Efficiency is a central concern in this problem. To enhance the search process, we transitioned from the BFS algorithm to the A* search algorithm. This change included replacing a regular queue with a priority queue and carefully choosing an admissible heuristic. These design choices were made to significantly improve the efficiency of our solution.

# Problem 2:
## Problem Formulation

### Initital State:
Given input board.

### State Space:
The state space consists of all possible configurations of the 5x5 sliding tile puzzle. Each configuration is represented as a tuple of 25 integers, where each integer corresponds to a tile on the puzzle board.

### Successor Function:
The successor function generates the possible successor states from the current state. Successor states are generated by performing rotations on the rows and columns of the grid. The following rotations are considered:
- Outer clockwise rotation (OC)
- Outer counter-clockwise rotation (OCC)
- Inner clockwise rotation (IC)
- Inner counter-clockwise rotation (ICC)
- Row left rotations (R1, R2, R3, R4, R5)
- Row right rotations (L1, L2, L3, L4, L5)
- Column up rotations (U1, U2, U3, U4, U5)
- Column down rotations (D1, D2, D3, D4, D5)

### Edge Weights:
The edge weights are not explicitly defined in this problem since the A* search algorithm is used. A* considers the cost of reaching a state from the initial state along with the heuristic estimate of the cost to reach the goal state. In this case, the cost is the number of moves taken to reach a state from the initial state.

### Goal State:
The goal state is defined as a sorted sequence of integers from 1 to 25, representing the tiles in ascending order from the top-left corner to the bottom-right corner of the puzzle.

### Heuristic Function:
he manhattan_distance function calculates the Manhattan distance between the current state and the goal state. It uses the sum of Manhattan distances between each tile and its target position. This heuristic is admissible because it never overestimates the true cost to reach the goal. The Manhattan distance between two cells (r1, c1) and (r2, c2) is defined as |r1 - r2| + |c1 - c2|.

## Search Algorithm
The search algorithm used to solve the puzzle is A* search. A* is an informed search algorithm that uses both the cost to reach a state from the initial state and a heuristic estimate of the cost to reach the goal state to guide its search.

1. Initialize an empty set to keep track of visited states.
2. Create a priority queue (min-heap) called the "fringe" to store states to explore. Each state in the fringe is associated with a priority value, which is the sum of the current cost to reach the state and the heuristic estimate of the cost to reach the goal state.
3. Initialize the current path as an empty list and the current cost as 0.
4. Push the initial state onto the fringe with its priority value calculated using the heuristic function.
5. While the fringe is not empty:
   - Pop the state with the highest priority value from the fringe.
   - Check if the current state is the goal state. If yes, return the current path as the solution.
   - Skip states that have already been visited.
   - Generate successor states from the current state using the successor function.
   - Calculate the priority values for each successor state and add them to the fringe.
6. If the fringe becomes empty and no solution is found, return None to indicate that the puzzle is unsolvable.

## Discussion

### Heuristic Choice:
The Manhattan distance heuristic was chosen because it is admissible and provides a good estimate of the number of moves required to reach the goal state. It is a common heuristic for sliding tile puzzles and works well in practice.

### Successor Function:
The successor function generates possible successor states by applying rotations to the rows and columns of the grid. This allows the search algorithm to explore a wide range of states efficiently. However, it's important to note that not all rotations are legal in a physical sliding tile puzzle, but this implementation considers all possible rotations for simplicity.

### Search Complexity:
The A* search algorithm guarantees optimality in finding the shortest path to the goal state. However, the search complexity can be high for larger puzzles or configurations with a large number of inversions. In such cases, the number of states to explore can grow exponentially, leading to longer search times.

### Performance Considerations:
The performance of the solver may vary depending on the initial state of the puzzle. Some initial states may be solved quickly, while others may require more exploration. The choice of heuristic can also impact performance. More sophisticated heuristics, such as pattern databases, could potentially be used to improve efficiency.

## Difficulties Faced:
The main challenge we encountered during the development of our sliding tile puzzle solver was the issue of convergence and finding an optimal heuristic. Initially, we solely relied on the Manhattan distance heuristic, but the algorithm took a considerable amount of time to converge, and in some cases, it failed to find an optimal solution.

To address this problem, we introduced the current cost into the heuristic calculation. This addition helped the algorithm converge more efficiently. By considering the cost incurred up to the current state, we provided the algorithm with a better estimate of the total cost to reach the goal state.

While this modification improved convergence, we were still in search of an ideal heuristic. One idea we considered was incorporating the square of the depth of the current state into the heuristic function. This approach would have increased the cost with greater depth, potentially encouraging the algorithm to explore more promising paths earlier. However, this approach also came with a drawbackâ€”it significantly increased computation time.

Another avenue we could have explored was using alternative distance metrics like the Euclidean distance. However, these alternatives might have produced suboptimal solutions or posed their own computational challenges.

In summary, the challenge we faced was finding the right balance between accuracy and computational efficiency in our heuristic function. While we improved convergence by adding the current cost to the Manhattan distance heuristic, achieving optimality without excessive computation time remained a complex task.

## Questions:
### 1. In this problem, what is the branching factor of the search tree? 
Ans. Moving 5 rows to left + 5 rows to right + 5 columns to up + 5 columns to down + 2 outer ring rotations (clockwise and anti-clockwise) + 2 inner ring rotations (clockwise and anti-clockwise) = 24.
Therefore, the branching factor for this search tree is 24.

### 2. If the solution can be reached in 7 moves, about how many states would we need to explore before we found it if we used BFS instead of A* search? A rough answer is fine. 
Ans. If the solution is reached in 7 moves, it would explore approximately 24^7 states before we found the solution.

# Problem 3
## Problem formulation

### The state space: 
The city list in the route which the car has passed.
### The successor function: 
The function to decide which road segment will be passed in the next step.
### The edge weights: 
  - Segments cost function: The edge is the road segment which connects two cities. The edge weight is 1, the number of the road segment between these two cities.
  - Distance cost function: The edge weight is the length of the road segment which connects two cities.
  - Time cost function:  The edge weight is the time cost which is needed to pass the road segment between two cities.
  - Delivery cost function: The edge weight is the number of expected accidents in this road segment.
### The goal state: 
The road between two cities with the least cost.
### The heuristic function: 
  - Segments cost function: The heuristic function is the rest segment number if each segment has the longest length in US and the distance between two cities is the Euclidean distance.
  
  - Distance cost function: The heuristic function is the Euclidean distance between the arrived city and the goal calculated by the coordinates of two cities. Considering that the shortest possible distance between two cities is the Euclidean distance.
  
  - Time cost function: the heuristic function is the time cost for a car to drive at the highest speed in the US through the Euclidean distance between the arrived city and the goal calculated by the coordinates of two cities. Considering that the lowest possible time cost is the cost for a car to drive at the highest speed through the shortest road.
  
  - Delivery cost function: The heuristic function is the expected accidents for a car to drive at the road with the lowest speed limit in the US through the Euclidean distance between the arrived city and the goal calculated by the coordinates of two cities. Considering that the lowest possible delivery cost is the cost for a car to meet the lowest expected accident, the lowest possible delivery cost is the cost for a car to drive at the lowest speed limited road through the shortest distance.

## Search algorithm
We used A* search algorithm in this part. For each time, we would choose the node with the lowest cost function `f = g + h` as the next city we would go to. After we arrived the node, we remove this node from the open set to the close set. Then, we would search the neighbors of this nodes. If the neighbors were not in the open set or the close set of the nodes, we would add them into the open set of the nodes. If the neighbors were in the open set, but their new cost function is small than their cost function in the open set, we would replace the old cost function with the new cost function in the open set. Then, we chose the next node. These steps would be looped until reaching the goal.

## Discussion
The Delivery cost function accounts for the possibility of packages falling out of a delivery driver's truck. It calculates the expected time for the driver to retrieve a replacement package and continue the journey. The probability of a package falling out is determined by the length of the road segment and the speed limit. This code offers a versatile and efficient solution for finding optimal driving routes in a road network. It can be applied in various scenarios, including route planning, logistics, and transportation, by considering different cost functions and providing valuable insights into route choices.
